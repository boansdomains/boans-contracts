{
  "address": "0xbf3a173Bbc5B81b057E7FedAd5d51a7b7C5e42DE",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ENS",
          "name": "_ens",
          "type": "address"
        },
        {
          "internalType": "contract INameWrapper",
          "name": "wrapperAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_trustedETHController",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_trustedReverseRegistrar",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "contentType",
          "type": "uint256"
        }
      ],
      "name": "ABIChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "a",
          "type": "address"
        }
      ],
      "name": "AddrChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "coinType",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "newAddress",
          "type": "bytes"
        }
      ],
      "name": "AddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "hash",
          "type": "bytes"
        }
      ],
      "name": "ContenthashChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "resource",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "record",
          "type": "bytes"
        }
      ],
      "name": "DNSRecordChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "resource",
          "type": "uint16"
        }
      ],
      "name": "DNSRecordDeleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "DNSZoneCleared",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "lastzonehash",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "zonehash",
          "type": "bytes"
        }
      ],
      "name": "DNSZonehashChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementer",
          "type": "address"
        }
      ],
      "name": "InterfaceChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "NameChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "x",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "y",
          "type": "bytes32"
        }
      ],
      "name": "PubkeyChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "string",
          "name": "indexedKey",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        }
      ],
      "name": "TextChanged",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "contentTypes",
          "type": "uint256"
        }
      ],
      "name": "ABI",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "addr",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "coinType",
          "type": "uint256"
        }
      ],
      "name": "addr",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "clearDNSZone",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "contenthash",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "resource",
          "type": "uint16"
        }
      ],
      "name": "dnsRecord",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        }
      ],
      "name": "hasDNSRecords",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "interfaceImplementer",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "pubkey",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "x",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "y",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "contentType",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "setABI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "coinType",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "a",
          "type": "bytes"
        }
      ],
      "name": "setAddr",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "a",
          "type": "address"
        }
      ],
      "name": "setAddr",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "hash",
          "type": "bytes"
        }
      ],
      "name": "setContenthash",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "setDNSRecords",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        },
        {
          "internalType": "address",
          "name": "implementer",
          "type": "address"
        }
      ],
      "name": "setInterface",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "newName",
          "type": "string"
        }
      ],
      "name": "setName",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "x",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "y",
          "type": "bytes32"
        }
      ],
      "name": "setPubkey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "value",
          "type": "string"
        }
      ],
      "name": "setText",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "hash",
          "type": "bytes"
        }
      ],
      "name": "setZonehash",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "key",
          "type": "string"
        }
      ],
      "name": "text",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "zonehash",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1fd46d806d9ec064ce6b7e7a260d3b8fd145ffc2e316118a52a9e7a1ebd8299a",
  "receipt": {
    "to": null,
    "from": "0x643c14DfeB3ea17458d702A1004FC7288AFE8Dcb",
    "contractAddress": "0xbf3a173Bbc5B81b057E7FedAd5d51a7b7C5e42DE",
    "transactionIndex": 0,
    "gasUsed": "2557371",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x457d50d4d2555465b5f23fa582dbfaa1a3d80aa169d67c36e8ca5d40e272b931",
    "transactionHash": "0x1fd46d806d9ec064ce6b7e7a260d3b8fd145ffc2e316118a52a9e7a1ebd8299a",
    "logs": [],
    "blockNumber": 252,
    "cumulativeGasUsed": "2557371",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xA32505eE9dAEF7f6189e699fD0f6983af8C97Cac",
    "0x268160619F51e6542F9920A3235139559DF0439d",
    "0x76CF12eF1a01C15F9b4bDB0AA7AC3dD09dfcB0C4",
    "0xD47f7e53A1d12EDF6B9d179bB1C33fC9c51417F6"
  ],
  "numDeployments": 1,
  "solcInputHash": "bfe2f3f8b503ffc082ee529a1f4da503",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"_ens\",\"type\":\"address\"},{\"internalType\":\"contract INameWrapper\",\"name\":\"wrapperAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trustedETHController\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trustedReverseRegistrar\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"contentType\",\"type\":\"uint256\"}],\"name\":\"ABIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"AddrChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"newAddress\",\"type\":\"bytes\"}],\"name\":\"AddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"ContenthashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"record\",\"type\":\"bytes\"}],\"name\":\"DNSRecordChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"DNSRecordDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"DNSZoneCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lastzonehash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"zonehash\",\"type\":\"bytes\"}],\"name\":\"DNSZonehashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"InterfaceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"PubkeyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"indexedKey\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"TextChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"contentTypes\",\"type\":\"uint256\"}],\"name\":\"ABI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"clearDNSZone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"contenthash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"dnsRecord\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"hasDNSRecords\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"interfaceImplementer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"pubkey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"contentType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setABI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"a\",\"type\":\"bytes\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setContenthash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setDNSRecords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"setInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"setPubkey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setZonehash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"text\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"zonehash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"ABI(bytes32,uint256)\":{\"params\":{\"contentTypes\":\"A bitwise OR of the ABI formats accepted by the caller.\",\"node\":\"The ENS node to query\"},\"returns\":{\"_0\":\"contentType The content type of the return value\",\"_1\":\"data The ABI data\"}},\"addr(bytes32)\":{\"params\":{\"node\":\"The ENS node to query.\"},\"returns\":{\"_0\":\"The associated address.\"}},\"clearDNSZone(bytes32)\":{\"params\":{\"node\":\"the namehash of the node for which to clear the zone\"}},\"contenthash(bytes32)\":{\"params\":{\"node\":\"The ENS node to query.\"},\"returns\":{\"_0\":\"The associated contenthash.\"}},\"dnsRecord(bytes32,bytes32,uint16)\":{\"params\":{\"name\":\"the keccak-256 hash of the fully-qualified name for which to fetch the record\",\"node\":\"the namehash of the node for which to fetch the record\",\"resource\":\"the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\"},\"returns\":{\"_0\":\"the DNS record in wire format if present, otherwise empty\"}},\"hasDNSRecords(bytes32,bytes32)\":{\"params\":{\"name\":\"the namehash of the node for which to check the records\",\"node\":\"the namehash of the node for which to check the records\"}},\"interfaceImplementer(bytes32,bytes4)\":{\"params\":{\"interfaceID\":\"The EIP 165 interface ID to check for.\",\"node\":\"The ENS node to query.\"},\"returns\":{\"_0\":\"The address that implements this interface, or 0 if the interface is unsupported.\"}},\"isApprovedForAll(address,address)\":{\"details\":\"See {IERC1155-isApprovedForAll}.\"},\"name(bytes32)\":{\"params\":{\"node\":\"The ENS node to query.\"},\"returns\":{\"_0\":\"The associated name.\"}},\"pubkey(bytes32)\":{\"params\":{\"node\":\"The ENS node to query\"},\"returns\":{\"x\":\"The X coordinate of the curve point for the public key.\",\"y\":\"The Y coordinate of the curve point for the public key.\"}},\"setABI(bytes32,uint256,bytes)\":{\"params\":{\"contentType\":\"The content type of the ABI\",\"data\":\"The ABI data.\",\"node\":\"The node to update.\"}},\"setAddr(bytes32,address)\":{\"params\":{\"a\":\"The address to set.\",\"node\":\"The node to update.\"}},\"setApprovalForAll(address,bool)\":{\"details\":\"See {IERC1155-setApprovalForAll}.\"},\"setContenthash(bytes32,bytes)\":{\"params\":{\"hash\":\"The contenthash to set\",\"node\":\"The node to update.\"}},\"setDNSRecords(bytes32,bytes)\":{\"params\":{\"data\":\"the DNS wire format records to set\",\"node\":\"the namehash of the node for which to set the records\"}},\"setInterface(bytes32,bytes4,address)\":{\"params\":{\"implementer\":\"The address of a contract that implements this interface for this node.\",\"interfaceID\":\"The EIP 165 interface ID.\",\"node\":\"The node to update.\"}},\"setName(bytes32,string)\":{\"params\":{\"node\":\"The node to update.\"}},\"setPubkey(bytes32,bytes32,bytes32)\":{\"params\":{\"node\":\"The ENS node to query\",\"x\":\"the X coordinate of the curve point for the public key.\",\"y\":\"the Y coordinate of the curve point for the public key.\"}},\"setText(bytes32,string,string)\":{\"params\":{\"key\":\"The key to set.\",\"node\":\"The node to update.\",\"value\":\"The text data value to set.\"}},\"setZonehash(bytes32,bytes)\":{\"params\":{\"hash\":\"The zonehash to set\",\"node\":\"The node to update.\"}},\"text(bytes32,string)\":{\"params\":{\"key\":\"The text data key to query.\",\"node\":\"The ENS node to query.\"},\"returns\":{\"_0\":\"The associated text data.\"}},\"zonehash(bytes32)\":{\"params\":{\"node\":\"The ENS node to query.\"},\"returns\":{\"_0\":\"The associated contenthash.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"ABI(bytes32,uint256)\":{\"notice\":\"Returns the ABI associated with an ENS node. Defined in EIP205.\"},\"addr(bytes32)\":{\"notice\":\"Returns the address associated with an ENS node.\"},\"clearDNSZone(bytes32)\":{\"notice\":\"Clear all information for a DNS zone.\"},\"contenthash(bytes32)\":{\"notice\":\"Returns the contenthash associated with an ENS node.\"},\"dnsRecord(bytes32,bytes32,uint16)\":{\"notice\":\"Obtain a DNS record.\"},\"hasDNSRecords(bytes32,bytes32)\":{\"notice\":\"Check if a given node has records.\"},\"interfaceImplementer(bytes32,bytes4)\":{\"notice\":\"Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP165 and returns `true` for the specified interfaceID, its address will be returned.\"},\"name(bytes32)\":{\"notice\":\"Returns the name associated with an ENS node, for reverse records. Defined in EIP181.\"},\"pubkey(bytes32)\":{\"notice\":\"Returns the SECP256k1 public key associated with an ENS node. Defined in EIP 619.\"},\"setABI(bytes32,uint256,bytes)\":{\"notice\":\"Sets the ABI associated with an ENS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string.\"},\"setAddr(bytes32,address)\":{\"notice\":\"Sets the address associated with an ENS node. May only be called by the owner of that node in the ENS registry.\"},\"setContenthash(bytes32,bytes)\":{\"notice\":\"Sets the contenthash associated with an ENS node. May only be called by the owner of that node in the ENS registry.\"},\"setDNSRecords(bytes32,bytes)\":{\"notice\":\"Set one or more DNS records.  Records are supplied in wire-format. Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:     a.example.com IN A 1.2.3.4     a.example.com IN A 5.6.7.8     www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:     a.example.com IN A 1.2.3.4     www.example.com IN CNAME a.example.com.     a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first.\"},\"setInterface(bytes32,bytes4,address)\":{\"notice\":\"Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\"},\"setName(bytes32,string)\":{\"notice\":\"Sets the name associated with an ENS node, for reverse records. May only be called by the owner of that node in the ENS registry.\"},\"setPubkey(bytes32,bytes32,bytes32)\":{\"notice\":\"Sets the SECP256k1 public key associated with an ENS node.\"},\"setText(bytes32,string,string)\":{\"notice\":\"Sets the text data associated with an ENS node and key. May only be called by the owner of that node in the ENS registry.\"},\"setZonehash(bytes32,bytes)\":{\"notice\":\"setZonehash sets the hash for the zone. May only be called by the owner of that node in the ENS registry.\"},\"text(bytes32,string)\":{\"notice\":\"Returns the text data associated with an ENS node and key.\"},\"zonehash(bytes32)\":{\"notice\":\"zonehash obtains the hash for the zone.\"}},\"notice\":\"A simple resolver anyone can use; only allows the owner of a node to set its address.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/resolvers/PublicResolver.sol\":\"PublicResolver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@ensdomains/buffer/contracts/Buffer.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for writing to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns(uint) {\\n        if (a > b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The start offset to write to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, len);\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write the byte at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\\n        if (off >= buf.capacity) {\\n            resize(buf, buf.capacity * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if eq(off, buflen) {\\n                mstore(bufptr, add(buflen, 1))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        return writeUint8(buf, buf.buf.length, data);\\n    }\\n\\n    /**\\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + off + len\\n                let dest := add(add(bufptr, off), len)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(add(off, len), mload(bufptr)) {\\n                    mstore(bufptr, add(off, len))\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, off, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, 32);\\n    }\\n\\n    /**\\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (right-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + off + sizeof(buffer length) + len\\n            let dest := add(add(bufptr, off), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(add(off, len), mload(bufptr)) {\\n                mstore(bufptr, add(off, len))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     * exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        return writeInt(buf, buf.buf.length, data, len);\\n    }\\n}\\n\",\"keccak256\":\"0x18e42be1a3e4f7b4442d7ab0b524af5e09163503439954faf0ab3792cce91caa\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary BytesUtils {\\n    /*\\n     * @dev Returns the keccak-256 hash of a byte range.\\n     * @param self The byte string to hash.\\n     * @param offset The position to start hashing at.\\n     * @param len The number of bytes to hash.\\n     * @return The hash of the byte range.\\n     */\\n    function keccak(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two bytes are equal.\\n     * @param self The first bytes to compare.\\n     * @param other The second bytes to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(bytes memory self, bytes memory other)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return compare(self, 0, self.length, other, 0, other.length);\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two bytes are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first bytes to compare.\\n     * @param offset The offset of self.\\n     * @param len    The length of self.\\n     * @param other The second bytes to compare.\\n     * @param otheroffset The offset of the other string.\\n     * @param otherlen    The length of the other string.\\n     * @return The result of the comparison.\\n     */\\n    function compare(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len,\\n        bytes memory other,\\n        uint256 otheroffset,\\n        uint256 otherlen\\n    ) internal pure returns (int256) {\\n        uint256 shortest = len;\\n        if (otherlen < len) shortest = otherlen;\\n\\n        uint256 selfptr;\\n        uint256 otherptr;\\n\\n        assembly {\\n            selfptr := add(self, add(offset, 32))\\n            otherptr := add(other, add(otheroffset, 32))\\n        }\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\n            uint256 a;\\n            uint256 b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint256 mask;\\n                if (shortest > 32) {\\n                    mask = type(uint256).max;\\n                } else {\\n                    mask = ~(2**(8 * (32 - shortest + idx)) - 1);\\n                }\\n                int256 diff = int256(a & mask) - int256(b & mask);\\n                if (diff != 0) return diff;\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n\\n        return int256(len) - int256(otherlen);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two byte ranges are equal.\\n     * @param self The first byte range to compare.\\n     * @param offset The offset into the first byte range.\\n     * @param other The second byte range to compare.\\n     * @param otherOffset The offset into the second byte range.\\n     * @param len The number of bytes to compare\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(\\n        bytes memory self,\\n        uint256 offset,\\n        bytes memory other,\\n        uint256 otherOffset,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two byte ranges are equal with offsets.\\n     * @param self The first byte range to compare.\\n     * @param offset The offset into the first byte range.\\n     * @param other The second byte range to compare.\\n     * @param otherOffset The offset into the second byte range.\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(\\n        bytes memory self,\\n        uint256 offset,\\n        bytes memory other,\\n        uint256 otherOffset\\n    ) internal pure returns (bool) {\\n        return\\n            keccak(self, offset, self.length - offset) ==\\n            keccak(other, otherOffset, other.length - otherOffset);\\n    }\\n\\n    /*\\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\\n     *      they are equal.\\n     * @param self The first byte range to compare.\\n     * @param offset The offset into the first byte range.\\n     * @param other The second byte range to compare.\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(\\n        bytes memory self,\\n        uint256 offset,\\n        bytes memory other\\n    ) internal pure returns (bool) {\\n        return\\n            self.length >= offset + other.length &&\\n            equals(self, offset, other, 0, other.length);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two byte ranges are equal.\\n     * @param self The first byte range to compare.\\n     * @param other The second byte range to compare.\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(bytes memory self, bytes memory other)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return\\n            self.length == other.length &&\\n            equals(self, 0, other, 0, self.length);\\n    }\\n\\n    /*\\n     * @dev Returns the 8-bit number at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 8 bits of the string, interpreted as an integer.\\n     */\\n    function readUint8(bytes memory self, uint256 idx)\\n        internal\\n        pure\\n        returns (uint8 ret)\\n    {\\n        return uint8(self[idx]);\\n    }\\n\\n    /*\\n     * @dev Returns the 16-bit number at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 16 bits of the string, interpreted as an integer.\\n     */\\n    function readUint16(bytes memory self, uint256 idx)\\n        internal\\n        pure\\n        returns (uint16 ret)\\n    {\\n        require(idx + 2 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the 32-bit number at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 32 bits of the string, interpreted as an integer.\\n     */\\n    function readUint32(bytes memory self, uint256 idx)\\n        internal\\n        pure\\n        returns (uint32 ret)\\n    {\\n        require(idx + 4 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the 32 byte value at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 32 bytes of the string.\\n     */\\n    function readBytes32(bytes memory self, uint256 idx)\\n        internal\\n        pure\\n        returns (bytes32 ret)\\n    {\\n        require(idx + 32 <= self.length);\\n        assembly {\\n            ret := mload(add(add(self, 32), idx))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the 32 byte value at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 32 bytes of the string.\\n     */\\n    function readBytes20(bytes memory self, uint256 idx)\\n        internal\\n        pure\\n        returns (bytes20 ret)\\n    {\\n        require(idx + 20 <= self.length);\\n        assembly {\\n            ret := and(\\n                mload(add(add(self, 32), idx)),\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the n byte value at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes.\\n     * @param len The number of bytes.\\n     * @return The specified 32 bytes of the string.\\n     */\\n    function readBytesN(\\n        bytes memory self,\\n        uint256 idx,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(len <= 32);\\n        require(idx + len <= self.length);\\n        assembly {\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\n        }\\n    }\\n\\n    function memcpy(\\n        uint256 dest,\\n        uint256 src,\\n        uint256 len\\n    ) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint256 mask = (256**(32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Copies a substring into a new byte string.\\n     * @param self The byte string to copy from.\\n     * @param offset The offset to start copying at.\\n     * @param len The number of bytes to copy.\\n     */\\n    function substring(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes memory) {\\n        require(offset + len <= self.length);\\n\\n        bytes memory ret = new bytes(len);\\n        uint256 dest;\\n        uint256 src;\\n\\n        assembly {\\n            dest := add(ret, 32)\\n            src := add(add(self, 32), offset)\\n        }\\n        memcpy(dest, src, len);\\n\\n        return ret;\\n    }\\n\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\n    // 0xFF represents invalid characters in that range.\\n    bytes constant base32HexTable =\\n        hex\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\";\\n\\n    /**\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\n     * @param self The data to decode.\\n     * @param off Offset into the string to start at.\\n     * @param len Number of characters to decode.\\n     * @return The decoded data, left aligned.\\n     */\\n    function base32HexDecodeWord(\\n        bytes memory self,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32) {\\n        require(len <= 52);\\n\\n        uint256 ret = 0;\\n        uint8 decoded;\\n        for (uint256 i = 0; i < len; i++) {\\n            bytes1 char = self[off + i];\\n            require(char >= 0x30 && char <= 0x7A);\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\n            require(decoded <= 0x20);\\n            if (i == len - 1) {\\n                break;\\n            }\\n            ret = (ret << 5) | decoded;\\n        }\\n\\n        uint256 bitlen = len * 5;\\n        if (len % 8 == 0) {\\n            // Multiple of 8 characters, no padding\\n            ret = (ret << 5) | decoded;\\n        } else if (len % 8 == 2) {\\n            // Two extra characters - 1 byte\\n            ret = (ret << 3) | (decoded >> 2);\\n            bitlen -= 2;\\n        } else if (len % 8 == 4) {\\n            // Four extra characters - 2 bytes\\n            ret = (ret << 1) | (decoded >> 4);\\n            bitlen -= 4;\\n        } else if (len % 8 == 5) {\\n            // Five extra characters - 3 bytes\\n            ret = (ret << 4) | (decoded >> 1);\\n            bitlen -= 1;\\n        } else if (len % 8 == 7) {\\n            // Seven extra characters - 4 bytes\\n            ret = (ret << 2) | (decoded >> 3);\\n            bitlen -= 3;\\n        } else {\\n            revert();\\n        }\\n\\n        return bytes32(ret << (256 - bitlen));\\n    }\\n}\\n\",\"keccak256\":\"0x9be1eba8c558adda3359c99e5a2b2c3376d0f649e9a07adc640246caf8bde160\"},\"contracts/dnssec-oracle/RRUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/**\\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\n */\\nlibrary RRUtils {\\n    using BytesUtils for *;\\n    using Buffer for *;\\n\\n    /**\\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\n     * @param self The byte array to read a name from.\\n     * @param offset The offset to start reading at.\\n     * @return The length of the DNS name at 'offset', in bytes.\\n     */\\n    function nameLength(bytes memory self, uint256 offset)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 idx = offset;\\n        while (true) {\\n            assert(idx < self.length);\\n            uint256 labelLen = self.readUint8(idx);\\n            idx += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n        }\\n        return idx - offset;\\n    }\\n\\n    /**\\n     * @dev Returns a DNS format name at the specified offset of self.\\n     * @param self The byte array to read a name from.\\n     * @param offset The offset to start reading at.\\n     * @return ret The name.\\n     */\\n    function readName(bytes memory self, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes memory ret)\\n    {\\n        uint256 len = nameLength(self, offset);\\n        return self.substring(offset, len);\\n    }\\n\\n    /**\\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\n     * @param self The byte array to read a name from.\\n     * @param offset The offset to start reading at.\\n     * @return The number of labels in the DNS name at 'offset', in bytes.\\n     */\\n    function labelCount(bytes memory self, uint256 offset)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 count = 0;\\n        while (true) {\\n            assert(offset < self.length);\\n            uint256 labelLen = self.readUint8(offset);\\n            offset += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n\\n    uint256 constant RRSIG_TYPE = 0;\\n    uint256 constant RRSIG_ALGORITHM = 2;\\n    uint256 constant RRSIG_LABELS = 3;\\n    uint256 constant RRSIG_TTL = 4;\\n    uint256 constant RRSIG_EXPIRATION = 8;\\n    uint256 constant RRSIG_INCEPTION = 12;\\n    uint256 constant RRSIG_KEY_TAG = 16;\\n    uint256 constant RRSIG_SIGNER_NAME = 18;\\n\\n    struct SignedSet {\\n        uint16 typeCovered;\\n        uint8 algorithm;\\n        uint8 labels;\\n        uint32 ttl;\\n        uint32 expiration;\\n        uint32 inception;\\n        uint16 keytag;\\n        bytes signerName;\\n        bytes data;\\n        bytes name;\\n    }\\n\\n    function readSignedSet(bytes memory data)\\n        internal\\n        pure\\n        returns (SignedSet memory self)\\n    {\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\n        self.labels = data.readUint8(RRSIG_LABELS);\\n        self.ttl = data.readUint32(RRSIG_TTL);\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\n        self.data = data.substring(\\n            RRSIG_SIGNER_NAME + self.signerName.length,\\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\\n        );\\n    }\\n\\n    function rrs(SignedSet memory rrset)\\n        internal\\n        pure\\n        returns (RRIterator memory)\\n    {\\n        return iterateRRs(rrset.data, 0);\\n    }\\n\\n    /**\\n     * @dev An iterator over resource records.\\n     */\\n    struct RRIterator {\\n        bytes data;\\n        uint256 offset;\\n        uint16 dnstype;\\n        uint16 class;\\n        uint32 ttl;\\n        uint256 rdataOffset;\\n        uint256 nextOffset;\\n    }\\n\\n    /**\\n     * @dev Begins iterating over resource records.\\n     * @param self The byte string to read from.\\n     * @param offset The offset to start reading at.\\n     * @return ret An iterator object.\\n     */\\n    function iterateRRs(bytes memory self, uint256 offset)\\n        internal\\n        pure\\n        returns (RRIterator memory ret)\\n    {\\n        ret.data = self;\\n        ret.nextOffset = offset;\\n        next(ret);\\n    }\\n\\n    /**\\n     * @dev Returns true iff there are more RRs to iterate.\\n     * @param iter The iterator to check.\\n     * @return True iff the iterator has finished.\\n     */\\n    function done(RRIterator memory iter) internal pure returns (bool) {\\n        return iter.offset >= iter.data.length;\\n    }\\n\\n    /**\\n     * @dev Moves the iterator to the next resource record.\\n     * @param iter The iterator to advance.\\n     */\\n    function next(RRIterator memory iter) internal pure {\\n        iter.offset = iter.nextOffset;\\n        if (iter.offset >= iter.data.length) {\\n            return;\\n        }\\n\\n        // Skip the name\\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\\n\\n        // Read type, class, and ttl\\n        iter.dnstype = iter.data.readUint16(off);\\n        off += 2;\\n        iter.class = iter.data.readUint16(off);\\n        off += 2;\\n        iter.ttl = iter.data.readUint32(off);\\n        off += 4;\\n\\n        // Read the rdata\\n        uint256 rdataLength = iter.data.readUint16(off);\\n        off += 2;\\n        iter.rdataOffset = off;\\n        iter.nextOffset = off + rdataLength;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the current record.\\n     * @param iter The iterator.\\n     * @return A new bytes object containing the owner name from the RR.\\n     */\\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.offset,\\n                nameLength(iter.data, iter.offset)\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the rdata portion of the current record.\\n     * @param iter The iterator.\\n     * @return A new bytes object containing the RR's RDATA.\\n     */\\n    function rdata(RRIterator memory iter)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            iter.data.substring(\\n                iter.rdataOffset,\\n                iter.nextOffset - iter.rdataOffset\\n            );\\n    }\\n\\n    uint256 constant DNSKEY_FLAGS = 0;\\n    uint256 constant DNSKEY_PROTOCOL = 2;\\n    uint256 constant DNSKEY_ALGORITHM = 3;\\n    uint256 constant DNSKEY_PUBKEY = 4;\\n\\n    struct DNSKEY {\\n        uint16 flags;\\n        uint8 protocol;\\n        uint8 algorithm;\\n        bytes publicKey;\\n    }\\n\\n    function readDNSKEY(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DNSKEY memory self) {\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\n        self.publicKey = data.substring(\\n            offset + DNSKEY_PUBKEY,\\n            length - DNSKEY_PUBKEY\\n        );\\n    }\\n\\n    uint256 constant DS_KEY_TAG = 0;\\n    uint256 constant DS_ALGORITHM = 2;\\n    uint256 constant DS_DIGEST_TYPE = 3;\\n    uint256 constant DS_DIGEST = 4;\\n\\n    struct DS {\\n        uint16 keytag;\\n        uint8 algorithm;\\n        uint8 digestType;\\n        bytes digest;\\n    }\\n\\n    function readDS(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DS memory self) {\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\n    }\\n\\n    struct NSEC3 {\\n        uint8 hashAlgorithm;\\n        uint8 flags;\\n        uint16 iterations;\\n        bytes salt;\\n        bytes32 nextHashedOwnerName;\\n        bytes typeBitmap;\\n    }\\n\\n    uint256 constant NSEC3_HASH_ALGORITHM = 0;\\n    uint256 constant NSEC3_FLAGS = 1;\\n    uint256 constant NSEC3_ITERATIONS = 2;\\n    uint256 constant NSEC3_SALT_LENGTH = 4;\\n    uint256 constant NSEC3_SALT = 5;\\n\\n    function readNSEC3(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (NSEC3 memory self) {\\n        uint256 end = offset + length;\\n        self.hashAlgorithm = data.readUint8(offset + NSEC3_HASH_ALGORITHM);\\n        self.flags = data.readUint8(offset + NSEC3_FLAGS);\\n        self.iterations = data.readUint16(offset + NSEC3_ITERATIONS);\\n        uint8 saltLength = data.readUint8(offset + NSEC3_SALT_LENGTH);\\n        offset = offset + NSEC3_SALT;\\n        self.salt = data.substring(offset, saltLength);\\n        offset += saltLength;\\n        uint8 nextLength = data.readUint8(offset);\\n        require(nextLength <= 32);\\n        offset += 1;\\n        self.nextHashedOwnerName = data.readBytesN(offset, nextLength);\\n        offset += nextLength;\\n        self.typeBitmap = data.substring(offset, end - offset);\\n    }\\n\\n    function checkTypeBitmap(NSEC3 memory self, uint16 rrtype)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return checkTypeBitmap(self.typeBitmap, 0, rrtype);\\n    }\\n\\n    /**\\n     * @dev Checks if a given RR type exists in a type bitmap.\\n     * @param bitmap The byte string to read the type bitmap from.\\n     * @param offset The offset to start reading at.\\n     * @param rrtype The RR type to check for.\\n     * @return True if the type is found in the bitmap, false otherwise.\\n     */\\n    function checkTypeBitmap(\\n        bytes memory bitmap,\\n        uint256 offset,\\n        uint16 rrtype\\n    ) internal pure returns (bool) {\\n        uint8 typeWindow = uint8(rrtype >> 8);\\n        uint8 windowByte = uint8((rrtype & 0xff) / 8);\\n        uint8 windowBitmask = uint8(\\n            uint8(1) << (uint8(7) - uint8(rrtype & 0x7))\\n        );\\n        for (uint256 off = offset; off < bitmap.length; ) {\\n            uint8 window = bitmap.readUint8(off);\\n            uint8 len = bitmap.readUint8(off + 1);\\n            if (typeWindow < window) {\\n                // We've gone past our window; it's not here.\\n                return false;\\n            } else if (typeWindow == window) {\\n                // Check this type bitmap\\n                if (len <= windowByte) {\\n                    // Our type is past the end of the bitmap\\n                    return false;\\n                }\\n                return\\n                    (bitmap.readUint8(off + windowByte + 2) & windowBitmask) !=\\n                    0;\\n            } else {\\n                // Skip this type bitmap\\n                off += len + 2;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function compareNames(bytes memory self, bytes memory other)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        if (self.equals(other)) {\\n            return 0;\\n        }\\n\\n        uint256 off;\\n        uint256 otheroff;\\n        uint256 prevoff;\\n        uint256 otherprevoff;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        // Keep removing labels from the front of the name until both names are equal length\\n        while (counts > othercounts) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        while (othercounts > counts) {\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            othercounts--;\\n        }\\n\\n        // Compare the last nonequal labels to each other\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            counts -= 1;\\n        }\\n\\n        if (off == 0) {\\n            return -1;\\n        }\\n        if (otheroff == 0) {\\n            return 1;\\n        }\\n\\n        return\\n            self.compare(\\n                prevoff + 1,\\n                self.readUint8(prevoff),\\n                other,\\n                otherprevoff + 1,\\n                other.readUint8(otherprevoff)\\n            );\\n    }\\n\\n    /**\\n     * @dev Compares two serial numbers using RFC1982 serial number math.\\n     */\\n    function serialNumberGte(uint32 i1, uint32 i2)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return int32(i1) - int32(i2) >= 0;\\n    }\\n\\n    function progress(bytes memory body, uint256 off)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return off + 1 + body.readUint8(off);\\n    }\\n\\n    /**\\n     * @dev Computes the keytag for a chunk of data.\\n     * @param data The data to compute a keytag for.\\n     * @return The computed key tag.\\n     */\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n        /* This function probably deserves some explanation.\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\\n         *\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n         *         uint ac;\\n         *         for (uint i = 0; i < data.length; i++) {\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\n         *         }\\n         *         return uint16(ac + (ac >> 16));\\n         *     }\\n         *\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\\n         * large words work in our favour.\\n         *\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\n         *\\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\\n         * and the remaining sums can be done just on ac1.\\n         */\\n        unchecked {\\n            require(data.length <= 8192, \\\"Long keys not permitted\\\");\\n            uint256 ac1;\\n            uint256 ac2;\\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(add(add(data, 32), i))\\n                }\\n                if (i + 32 > data.length) {\\n                    uint256 unused = 256 - (data.length - i) * 8;\\n                    word = (word >> unused) << unused;\\n                }\\n                ac1 +=\\n                    (word &\\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\\n                    8;\\n                ac2 += (word &\\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\n            }\\n            ac1 =\\n                (ac1 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac1 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac2 =\\n                (ac2 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac2 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac1 = (ac1 << 8) + ac2;\\n            ac1 =\\n                (ac1 &\\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\\n                    32);\\n            ac1 =\\n                (ac1 &\\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\n                    64);\\n            ac1 =\\n                (ac1 &\\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\\n                (ac1 >> 128);\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\n            return uint16(ac1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfc962fbb0b5bc2dbc7559b7d78f95e5e297b76680e06dac5497cf653d985a2ef\"},\"contracts/registry/ENS.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0xf79be82c1a2eb0a77fba4e0972221912e803309081ca460fd2cf61653e55758a\"},\"contracts/resolvers/IMulticallable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMulticallable {\\n    function multicall(bytes[] calldata data)\\n        external\\n        returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x447dccdc523d06c9e7dc85d89d9dad628526b16299ac2ba5dc87edcceeb201e9\",\"license\":\"MIT\"},\"contracts/resolvers/Multicallable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IMulticallable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nabstract contract Multicallable is IMulticallable, ERC165 {\\n    function multicall(bytes[] calldata data)\\n        external\\n        override\\n        returns (bytes[] memory results)\\n    {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(\\n                data[i]\\n            );\\n            require(success);\\n            results[i] = result;\\n        }\\n        return results;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(IMulticallable).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x6cd4fbcbff32bf4aa4ef5596ad90ee0d10dd1677b0610b5a7366dedd404f9d25\",\"license\":\"MIT\"},\"contracts/resolvers/PublicResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../registry/ENS.sol\\\";\\nimport \\\"./profiles/ABIResolver.sol\\\";\\nimport \\\"./profiles/AddrResolver.sol\\\";\\nimport \\\"./profiles/ContentHashResolver.sol\\\";\\nimport \\\"./profiles/DNSResolver.sol\\\";\\nimport \\\"./profiles/InterfaceResolver.sol\\\";\\nimport \\\"./profiles/NameResolver.sol\\\";\\nimport \\\"./profiles/PubkeyResolver.sol\\\";\\nimport \\\"./profiles/TextResolver.sol\\\";\\nimport \\\"./Multicallable.sol\\\";\\n\\ninterface INameWrapper {\\n    function ownerOf(uint256 id) external view returns (address);\\n}\\n\\n/**\\n * A simple resolver anyone can use; only allows the owner of a node to set its\\n * address.\\n */\\ncontract PublicResolver is\\n    Multicallable,\\n    ABIResolver,\\n    AddrResolver,\\n    ContentHashResolver,\\n    DNSResolver,\\n    InterfaceResolver,\\n    NameResolver,\\n    PubkeyResolver,\\n    TextResolver\\n{\\n    ENS immutable ens;\\n    INameWrapper immutable nameWrapper;\\n    address immutable trustedETHController;\\n    address immutable trustedReverseRegistrar;\\n\\n    /**\\n     * A mapping of operators. An address that is authorised for an address\\n     * may make any changes to the name that the owner could, but may not update\\n     * the set of authorisations.\\n     * (owner, operator) => approved\\n     */\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    constructor(\\n        ENS _ens,\\n        INameWrapper wrapperAddress,\\n        address _trustedETHController,\\n        address _trustedReverseRegistrar\\n    ) {\\n        ens = _ens;\\n        nameWrapper = wrapperAddress;\\n        trustedETHController = _trustedETHController;\\n        trustedReverseRegistrar = _trustedReverseRegistrar;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external {\\n        require(\\n            msg.sender != operator,\\n            \\\"ERC1155: setting approval status for self\\\"\\n        );\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\\n        if (\\n            msg.sender == trustedETHController ||\\n            msg.sender == trustedReverseRegistrar\\n        ) {\\n            return true;\\n        }\\n        address owner = ens.owner(node);\\n        if (owner == address(nameWrapper)) {\\n            owner = nameWrapper.ownerOf(uint256(node));\\n        }\\n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        override(\\n            Multicallable,\\n            ABIResolver,\\n            AddrResolver,\\n            ContentHashResolver,\\n            DNSResolver,\\n            InterfaceResolver,\\n            NameResolver,\\n            PubkeyResolver,\\n            TextResolver\\n        )\\n        returns (bool)\\n    {\\n        return super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0xf99eb50774281912adcbdbf0daf1c8006db2d4de4bab837bbfc0d75a91e312a7\",\"license\":\"MIT\"},\"contracts/resolvers/ResolverBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nabstract contract ResolverBase is ERC165 {\\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node));\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xc749aecc4b1ea253d7ba60d130014954dd0dd327c085b1863f8bb7ad3e32f2e3\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/ABIResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IABIResolver.sol\\\";\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract ABIResolver is IABIResolver, ResolverBase {\\n    mapping(bytes32 => mapping(uint256 => bytes)) abis;\\n\\n    /**\\n     * Sets the ABI associated with an ENS node.\\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\\n     * the empty string.\\n     * @param node The node to update.\\n     * @param contentType The content type of the ABI\\n     * @param data The ABI data.\\n     */\\n    function setABI(\\n        bytes32 node,\\n        uint256 contentType,\\n        bytes calldata data\\n    ) external virtual authorised(node) {\\n        // Content types must be powers of 2\\n        require(((contentType - 1) & contentType) == 0);\\n\\n        abis[node][contentType] = data;\\n        emit ABIChanged(node, contentType);\\n    }\\n\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256, bytes memory)\\n    {\\n        mapping(uint256 => bytes) storage abiset = abis[node];\\n\\n        for (\\n            uint256 contentType = 1;\\n            contentType <= contentTypes;\\n            contentType <<= 1\\n        ) {\\n            if (\\n                (contentType & contentTypes) != 0 &&\\n                abiset[contentType].length > 0\\n            ) {\\n                return (contentType, abiset[contentType]);\\n            }\\n        }\\n\\n        return (0, bytes(\\\"\\\"));\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(IABIResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x4ff497128885130779cbb42a9031459dabda76c0cda411025cbd09ccb8468f88\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/AddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./IAddrResolver.sol\\\";\\nimport \\\"./IAddressResolver.sol\\\";\\n\\nabstract contract AddrResolver is\\n    IAddrResolver,\\n    IAddressResolver,\\n    ResolverBase\\n{\\n    uint256 private constant COIN_TYPE_ETH = 60;\\n\\n    mapping(bytes32 => mapping(uint256 => bytes)) _addresses;\\n\\n    /**\\n     * Sets the address associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param a The address to set.\\n     */\\n    function setAddr(bytes32 node, address a)\\n        external\\n        virtual\\n        authorised(node)\\n    {\\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\\n    }\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address payable)\\n    {\\n        bytes memory a = addr(node, COIN_TYPE_ETH);\\n        if (a.length == 0) {\\n            return payable(0);\\n        }\\n        return bytesToAddress(a);\\n    }\\n\\n    function setAddr(\\n        bytes32 node,\\n        uint256 coinType,\\n        bytes memory a\\n    ) public virtual authorised(node) {\\n        emit AddressChanged(node, coinType, a);\\n        if (coinType == COIN_TYPE_ETH) {\\n            emit AddrChanged(node, bytesToAddress(a));\\n        }\\n        _addresses[node][coinType] = a;\\n    }\\n\\n    function addr(bytes32 node, uint256 coinType)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        return _addresses[node][coinType];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(IAddrResolver).interfaceId ||\\n            interfaceID == type(IAddressResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n\\n    function bytesToAddress(bytes memory b)\\n        internal\\n        pure\\n        returns (address payable a)\\n    {\\n        require(b.length == 20);\\n        assembly {\\n            a := div(mload(add(b, 32)), exp(256, 12))\\n        }\\n    }\\n\\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\\n        b = new bytes(20);\\n        assembly {\\n            mstore(add(b, 32), mul(a, exp(256, 12)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1fa0a928fb105abad9477fdd9917a28f362a817ba3105438f25ee0bd5c1548b6\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/ContentHashResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./IContentHashResolver.sol\\\";\\n\\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\\n    mapping(bytes32 => bytes) hashes;\\n\\n    /**\\n     * Sets the contenthash associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The contenthash to set\\n     */\\n    function setContenthash(bytes32 node, bytes calldata hash)\\n        external\\n        virtual\\n        authorised(node)\\n    {\\n        hashes[node] = hash;\\n        emit ContenthashChanged(node, hash);\\n    }\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        return hashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(IContentHashResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0xf3db2af9dbdec368df3874518c23ce9194ce272f548ad168c1d8b60e2c0a4371\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/DNSResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"../../dnssec-oracle/RRUtils.sol\\\";\\nimport \\\"./IDNSRecordResolver.sol\\\";\\nimport \\\"./IDNSZoneResolver.sol\\\";\\n\\nabstract contract DNSResolver is\\n    IDNSRecordResolver,\\n    IDNSZoneResolver,\\n    ResolverBase\\n{\\n    using RRUtils for *;\\n    using BytesUtils for bytes;\\n\\n    // Zone hashes for the domains.\\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\\n    // resource containing a single zonefile.\\n    // node => contenthash\\n    mapping(bytes32 => bytes) private zonehashes;\\n\\n    // Version the mapping for each zone.  This allows users who have lost\\n    // track of their entries to effectively delete an entire zone by bumping\\n    // the version number.\\n    // node => version\\n    mapping(bytes32 => uint256) private versions;\\n\\n    // The records themselves.  Stored as binary RRSETs\\n    // node => version => name => resource => data\\n    mapping(bytes32 => mapping(uint256 => mapping(bytes32 => mapping(uint16 => bytes))))\\n        private records;\\n\\n    // Count of number of entries for a given name.  Required for DNS resolvers\\n    // when resolving wildcards.\\n    // node => version => name => number of records\\n    mapping(bytes32 => mapping(uint256 => mapping(bytes32 => uint16)))\\n        private nameEntriesCount;\\n\\n    /**\\n     * Set one or more DNS records.  Records are supplied in wire-format.\\n     * Records with the same node/name/resource must be supplied one after the\\n     * other to ensure the data is updated correctly. For example, if the data\\n     * was supplied:\\n     *     a.example.com IN A 1.2.3.4\\n     *     a.example.com IN A 5.6.7.8\\n     *     www.example.com IN CNAME a.example.com.\\n     * then this would store the two A records for a.example.com correctly as a\\n     * single RRSET, however if the data was supplied:\\n     *     a.example.com IN A 1.2.3.4\\n     *     www.example.com IN CNAME a.example.com.\\n     *     a.example.com IN A 5.6.7.8\\n     * then this would store the first A record, the CNAME, then the second A\\n     * record which would overwrite the first.\\n     *\\n     * @param node the namehash of the node for which to set the records\\n     * @param data the DNS wire format records to set\\n     */\\n    function setDNSRecords(bytes32 node, bytes calldata data)\\n        external\\n        virtual\\n        authorised(node)\\n    {\\n        uint16 resource = 0;\\n        uint256 offset = 0;\\n        bytes memory name;\\n        bytes memory value;\\n        bytes32 nameHash;\\n        // Iterate over the data to add the resource records\\n        for (\\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\\n            !iter.done();\\n            iter.next()\\n        ) {\\n            if (resource == 0) {\\n                resource = iter.dnstype;\\n                name = iter.name();\\n                nameHash = keccak256(abi.encodePacked(name));\\n                value = bytes(iter.rdata());\\n            } else {\\n                bytes memory newName = iter.name();\\n                if (resource != iter.dnstype || !name.equals(newName)) {\\n                    setDNSRRSet(\\n                        node,\\n                        name,\\n                        resource,\\n                        data,\\n                        offset,\\n                        iter.offset - offset,\\n                        value.length == 0\\n                    );\\n                    resource = iter.dnstype;\\n                    offset = iter.offset;\\n                    name = newName;\\n                    nameHash = keccak256(name);\\n                    value = bytes(iter.rdata());\\n                }\\n            }\\n        }\\n        if (name.length > 0) {\\n            setDNSRRSet(\\n                node,\\n                name,\\n                resource,\\n                data,\\n                offset,\\n                data.length - offset,\\n                value.length == 0\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Obtain a DNS record.\\n     * @param node the namehash of the node for which to fetch the record\\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\n     * @return the DNS record in wire format if present, otherwise empty\\n     */\\n    function dnsRecord(\\n        bytes32 node,\\n        bytes32 name,\\n        uint16 resource\\n    ) public view virtual override returns (bytes memory) {\\n        return records[node][versions[node]][name][resource];\\n    }\\n\\n    /**\\n     * Check if a given node has records.\\n     * @param node the namehash of the node for which to check the records\\n     * @param name the namehash of the node for which to check the records\\n     */\\n    function hasDNSRecords(bytes32 node, bytes32 name)\\n        public\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        return (nameEntriesCount[node][versions[node]][name] != 0);\\n    }\\n\\n    /**\\n     * Clear all information for a DNS zone.\\n     * @param node the namehash of the node for which to clear the zone\\n     */\\n    function clearDNSZone(bytes32 node) public virtual authorised(node) {\\n        versions[node]++;\\n        emit DNSZoneCleared(node);\\n    }\\n\\n    /**\\n     * setZonehash sets the hash for the zone.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The zonehash to set\\n     */\\n    function setZonehash(bytes32 node, bytes calldata hash)\\n        external\\n        virtual\\n        authorised(node)\\n    {\\n        bytes memory oldhash = zonehashes[node];\\n        zonehashes[node] = hash;\\n        emit DNSZonehashChanged(node, oldhash, hash);\\n    }\\n\\n    /**\\n     * zonehash obtains the hash for the zone.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function zonehash(bytes32 node)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        return zonehashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\\n            interfaceID == type(IDNSZoneResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n\\n    function setDNSRRSet(\\n        bytes32 node,\\n        bytes memory name,\\n        uint16 resource,\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 size,\\n        bool deleteRecord\\n    ) private {\\n        uint256 version = versions[node];\\n        bytes32 nameHash = keccak256(name);\\n        bytes memory rrData = data.substring(offset, size);\\n        if (deleteRecord) {\\n            if (records[node][version][nameHash][resource].length != 0) {\\n                nameEntriesCount[node][version][nameHash]--;\\n            }\\n            delete (records[node][version][nameHash][resource]);\\n            emit DNSRecordDeleted(node, name, resource);\\n        } else {\\n            if (records[node][version][nameHash][resource].length == 0) {\\n                nameEntriesCount[node][version][nameHash]++;\\n            }\\n            records[node][version][nameHash][resource] = rrData;\\n            emit DNSRecordChanged(node, name, resource, rrData);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa067664296b51b243fde015601b96a0bfb1d8c1e2007095f3ec3f49ab0c3f07f\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IABIResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IABIResolver.sol\\\";\\nimport \\\"../ResolverBase.sol\\\";\\n\\ninterface IABIResolver {\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes)\\n        external\\n        view\\n        returns (uint256, bytes memory);\\n}\\n\",\"keccak256\":\"0xc6db25d9b07ea925c64bb777f00ba557e99fbccd4c30c20e5a1b5cd8c159dcbf\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the legacy (ETH-only) addr function.\\n */\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x2ad7f2fc60ebe0f93745fe70247f6a854f66af732483fda2a3c5e055614445e8\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the new (multicoin) addr function.\\n */\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(bytes32 node, uint256 coinType)\\n        external\\n        view\\n        returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x37221203e063dee5aa2a067a6ab3401e9cca41cce5b15230994b6ea377f05ed5\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IContentHashResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IContentHashResolver {\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xd95cd77684ba5752c428d7dceb4ecc6506ac94f4fbb910489637eb68dcd8e366\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IDNSRecordResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IDNSRecordResolver {\\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\\n    event DNSRecordChanged(\\n        bytes32 indexed node,\\n        bytes name,\\n        uint16 resource,\\n        bytes record\\n    );\\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\\n    // DNSZoneCleared is emitted whenever a given node's zone information is cleared.\\n    event DNSZoneCleared(bytes32 indexed node);\\n\\n    /**\\n     * Obtain a DNS record.\\n     * @param node the namehash of the node for which to fetch the record\\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\n     * @return the DNS record in wire format if present, otherwise empty\\n     */\\n    function dnsRecord(\\n        bytes32 node,\\n        bytes32 name,\\n        uint16 resource\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x78cfc99568f9b092692d825b7c8f29ccc02c057e0ef2707ce037a1b4381c7fc2\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IDNSZoneResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IDNSZoneResolver {\\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\\n    event DNSZonehashChanged(\\n        bytes32 indexed node,\\n        bytes lastzonehash,\\n        bytes zonehash\\n    );\\n\\n    /**\\n     * zonehash obtains the hash for the zone.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function zonehash(bytes32 node) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xca1b3a16e7005533f2800a3e66fcdccf7c574deac7913d8c810f40aec1d58dc0\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IInterfaceResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IInterfaceResolver {\\n    event InterfaceChanged(\\n        bytes32 indexed node,\\n        bytes4 indexed interfaceID,\\n        address implementer\\n    );\\n\\n    /**\\n     * Returns the address of a contract that implements the specified interface for this name.\\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\\n     * will be returned.\\n     * @param node The ENS node to query.\\n     * @param interfaceID The EIP 165 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID)\\n        external\\n        view\\n        returns (address);\\n}\\n\",\"keccak256\":\"0x6d75d6010016684030e13711b3bc1a4e1a784c7398937f1b7c2b2f328f962c2b\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/INameResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface INameResolver {\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ec392b612447b1acbdc01114f2da2837a658d3f3157f60a99c5269f0b623346\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IPubkeyResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IPubkeyResolver {\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n}\\n\",\"keccak256\":\"0x69748947093dd2fda9ddcebd0adf19a6d1e7600df1d4b1462a0417156caddca7\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/ITextResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ITextResolver {\\n    event TextChanged(\\n        bytes32 indexed node,\\n        string indexed indexedKey,\\n        string key\\n    );\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key)\\n        external\\n        view\\n        returns (string memory);\\n}\\n\",\"keccak256\":\"0x286e9733ac489cb2d07255e8aba1f48a0e350bc8988a7c76594886bdbbfc29df\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/InterfaceResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./AddrResolver.sol\\\";\\nimport \\\"./IInterfaceResolver.sol\\\";\\n\\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\\n    mapping(bytes32 => mapping(bytes4 => address)) interfaces;\\n\\n    /**\\n     * Sets an interface associated with a name.\\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\n     * @param node The node to update.\\n     * @param interfaceID The EIP 165 interface ID.\\n     * @param implementer The address of a contract that implements this interface for this node.\\n     */\\n    function setInterface(\\n        bytes32 node,\\n        bytes4 interfaceID,\\n        address implementer\\n    ) external virtual authorised(node) {\\n        interfaces[node][interfaceID] = implementer;\\n        emit InterfaceChanged(node, interfaceID, implementer);\\n    }\\n\\n    /**\\n     * Returns the address of a contract that implements the specified interface for this name.\\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\\n     * will be returned.\\n     * @param node The ENS node to query.\\n     * @param interfaceID The EIP 165 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        address implementer = interfaces[node][interfaceID];\\n        if (implementer != address(0)) {\\n            return implementer;\\n        }\\n\\n        address a = addr(node);\\n        if (a == address(0)) {\\n            return address(0);\\n        }\\n\\n        (bool success, bytes memory returnData) = a.staticcall(\\n            abi.encodeWithSignature(\\n                \\\"supportsInterface(bytes4)\\\",\\n                type(IERC165).interfaceId\\n            )\\n        );\\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\\n            // EIP 165 not supported by target\\n            return address(0);\\n        }\\n\\n        (success, returnData) = a.staticcall(\\n            abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", interfaceID)\\n        );\\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\\n            // Specified interface not supported by target\\n            return address(0);\\n        }\\n\\n        return a;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(IInterfaceResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x74df0149113dc18c40ca94d7645e5277225460ec5fde399db13b2a173564e95b\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/NameResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./INameResolver.sol\\\";\\n\\nabstract contract NameResolver is INameResolver, ResolverBase {\\n    mapping(bytes32 => string) names;\\n\\n    /**\\n     * Sets the name associated with an ENS node, for reverse records.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     */\\n    function setName(bytes32 node, string calldata newName)\\n        external\\n        virtual\\n        authorised(node)\\n    {\\n        names[node] = newName;\\n        emit NameChanged(node, newName);\\n    }\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        return names[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(INameResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0xa396d5b4f8be2d5da56cf30d7a3ee16d55f1f179c17c348dc61b27da0c7418da\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/PubkeyResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./IPubkeyResolver.sol\\\";\\n\\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\\n    struct PublicKey {\\n        bytes32 x;\\n        bytes32 y;\\n    }\\n\\n    mapping(bytes32 => PublicKey) pubkeys;\\n\\n    /**\\n     * Sets the SECP256k1 public key associated with an ENS node.\\n     * @param node The ENS node to query\\n     * @param x the X coordinate of the curve point for the public key.\\n     * @param y the Y coordinate of the curve point for the public key.\\n     */\\n    function setPubkey(\\n        bytes32 node,\\n        bytes32 x,\\n        bytes32 y\\n    ) external virtual authorised(node) {\\n        pubkeys[node] = PublicKey(x, y);\\n        emit PubkeyChanged(node, x, y);\\n    }\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes32 x, bytes32 y)\\n    {\\n        return (pubkeys[node].x, pubkeys[node].y);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(IPubkeyResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0xd4cfb76a794b96a7ea20d536ef0baa0516a0e678bfd46c60a9c48469271c3eea\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/TextResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./ITextResolver.sol\\\";\\n\\nabstract contract TextResolver is ITextResolver, ResolverBase {\\n    mapping(bytes32 => mapping(string => string)) texts;\\n\\n    /**\\n     * Sets the text data associated with an ENS node and key.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param key The key to set.\\n     * @param value The text data value to set.\\n     */\\n    function setText(\\n        bytes32 node,\\n        string calldata key,\\n        string calldata value\\n    ) external virtual authorised(node) {\\n        texts[node][key] = value;\\n        emit TextChanged(node, key, key);\\n    }\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        return texts[node][key];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == type(ITextResolver).interfaceId ||\\n            super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x00af9adefdd045e252ba40727718574f74164e7fc4cde0a27349e75c2894cf93\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101006040523480156200001257600080fd5b5060405162002e9838038062002e98833981016040819052620000359162000071565b6001600160a01b0393841660805291831660a052821660c0521660e052620000d9565b6001600160a01b03811681146200006e57600080fd5b50565b600080600080608085870312156200008857600080fd5b8451620000958162000058565b6020860151909450620000a88162000058565b6040860151909350620000bb8162000058565b6060860151909250620000ce8162000058565b939692955090935050565b60805160a05160c05160e051612d7e6200011a60003960006116980152600061165901526000818161177d01526117fd015260006116f90152612d7e6000f3fe608060405234801561001057600080fd5b50600436106101ae5760003560e01c806377372213116100ee578063bc1c58d111610097578063d5fa2b0011610071578063d5fa2b0014610410578063e59d895d14610423578063e985e9c514610436578063f1cb7e061461047f57600080fd5b8063bc1c58d1146103ad578063c8690233146103c0578063ce3decdc146103fd57600080fd5b8063a8fa5682116100c8578063a8fa568214610367578063ac9650d81461037a578063ad5780af1461039a57600080fd5b8063773722131461032e5780638b95dd7114610341578063a22cb4651461035457600080fd5b8063304e6ade1161015b57806359d1d43c1161013557806359d1d43c146102d55780635c98042b146102f5578063623195b014610308578063691f34311461031b57600080fd5b8063304e6ade1461026f5780633b3b57de146102825780634cbf6ba41461029557600080fd5b8063124a319c1161018c578063124a319c146102035780632203ab561461023b57806329cd62ea1461025c57600080fd5b806301ffc9a7146101b35780630af179d7146101db57806310f13a8c146101f0575b600080fd5b6101c66101c1366004612437565b610492565b60405190151581526020015b60405180910390f35b6101ee6101e9366004612494565b6104a3565b005b6101ee6101fe3660046124e0565b610691565b61021661021136600461255a565b61073e565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101d2565b61024e610249366004612586565b610abb565b6040516101d2929190612622565b6101ee61026a36600461263b565b610bd6565b6101ee61027d366004612494565b610c56565b610216610290366004612667565b610cb5565b6101c66102a3366004612586565b600091825260066020908152604080842060048352818520548552825280842092845291905290205461ffff16151590565b6102e86102e3366004612494565b610ce7565b6040516101d29190612680565b6102e8610303366004612667565b610dac565b6101ee610316366004612693565b610e4e565b6102e8610329366004612667565b610ecf565b6101ee61033c366004612494565b610eec565b6101ee61034f366004612715565b610f4b565b6101ee610362366004612819565b611022565b6102e8610375366004612857565b611162565b61038d610388366004612897565b6111a5565b6040516101d2919061290c565b6101ee6103a8366004612667565b6112c0565b6102e86103bb366004612667565b611321565b6103e86103ce366004612667565b600090815260096020526040902080546001909101549091565b604080519283526020830191909152016101d2565b6101ee61040b366004612494565b61133e565b6101ee61041e36600461298c565b61144a565b6101ee6104313660046129b1565b611471565b6101c66104443660046129e6565b73ffffffffffffffffffffffffffffffffffffffff9182166000908152600b6020908152604080832093909416825291909152205460ff1690565b6102e861048d366004612586565b61153b565b600061049d826115e9565b92915050565b826104ad8161163f565b6104b657600080fd5b60008060608060008061050360008a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506118d89050565b90505b8051516020820151101561062c578561ffff1660000361056b578060400151955061053081611939565b9350836040516020016105439190612a14565b6040516020818303038152906040528051906020012091506105648161195a565b925061061e565b600061057682611939565b9050816040015161ffff168761ffff1614158061059a57506105988582611976565b155b1561061c576105f58b86898d8d8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505060208801518c91506105ed908290612a5f565b8a5115611994565b8160400151965081602001519550809450848051906020012092506106198261195a565b93505b505b61062781611bd7565b610506565b50825115610686576106868984878b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508b925061067e91508290508e612a5f565b885115611994565b505050505050505050565b8461069b8161163f565b6106a457600080fd5b8282600a600089815260200190815260200160002087876040516106c9929190612a76565b9081526040519081900360200190206106e392909161229a565b5084846040516106f4929190612a76565b6040518091039020867fd8c9334b1a9c2f9da342a0a2b32629c1a229b6445dad78947f674b44444a7550878760405161072e929190612acf565b60405180910390a3505050505050565b60008281526007602090815260408083207fffffffff000000000000000000000000000000000000000000000000000000008516845290915281205473ffffffffffffffffffffffffffffffffffffffff16801561079d57905061049d565b60006107a885610cb5565b905073ffffffffffffffffffffffffffffffffffffffff81166107d05760009250505061049d565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000006024820152600090819073ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a7000000000000000000000000000000000000000000000000000000001790525161089a9190612a14565b600060405180830381855afa9150503d80600081146108d5576040519150601f19603f3d011682016040523d82523d6000602084013e6108da565b606091505b50915091508115806108ed575060208151105b8061092f575080601f8151811061090657610906612ae3565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b1561094157600094505050505061049d565b6040517fffffffff000000000000000000000000000000000000000000000000000000008716602482015273ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a70000000000000000000000000000000000000000000000000000000017905251610a089190612a14565b600060405180830381855afa9150503d8060008114610a43576040519150601f19603f3d011682016040523d82523d6000602084013e610a48565b606091505b509092509050811580610a5c575060208151105b80610a9e575080601f81518110610a7557610a75612ae3565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b15610ab057600094505050505061049d565b509095945050505050565b600082815260208190526040812060609060015b848111610bb65780851615801590610aff575060008181526020839052604081208054610afb90612b12565b9050115b15610bae5780826000838152602001908152602001600020808054610b2390612b12565b80601f0160208091040260200160405190810160405280929190818152602001828054610b4f90612b12565b8015610b9c5780601f10610b7157610100808354040283529160200191610b9c565b820191906000526020600020905b815481529060010190602001808311610b7f57829003601f168201915b50505050509050935093505050610bcf565b60011b610acf565b5060006040518060200160405280600081525092509250505b9250929050565b82610be08161163f565b610be957600080fd5b60408051808201825284815260208082018581526000888152600983528490209251835551600190920191909155815185815290810184905285917f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e4691015b60405180910390a250505050565b82610c608161163f565b610c6957600080fd5b6000848152600260205260409020610c8290848461229a565b50837fe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d75788484604051610c48929190612acf565b600080610cc383603c61153b565b90508051600003610cd75750600092915050565b610ce081611cbf565b9392505050565b6060600a60008581526020019081526020016000208383604051610d0c929190612a76565b90815260200160405180910390208054610d2590612b12565b80601f0160208091040260200160405190810160405280929190818152602001828054610d5190612b12565b8015610d9e5780601f10610d7357610100808354040283529160200191610d9e565b820191906000526020600020905b815481529060010190602001808311610d8157829003601f168201915b505050505090509392505050565b6000818152600360205260409020805460609190610dc990612b12565b80601f0160208091040260200160405190810160405280929190818152602001828054610df590612b12565b8015610e425780601f10610e1757610100808354040283529160200191610e42565b820191906000526020600020905b815481529060010190602001808311610e2557829003601f168201915b50505050509050919050565b83610e588161163f565b610e6157600080fd5b83610e6d600182612a5f565b1615610e7857600080fd5b6000858152602081815260408083208784529091529020610e9a90848461229a565b50604051849086907faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe390600090a35050505050565b6000818152600860205260409020805460609190610dc990612b12565b82610ef68161163f565b610eff57600080fd5b6000848152600860205260409020610f1890848461229a565b50837fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f78484604051610c48929190612acf565b82610f558161163f565b610f5e57600080fd5b837f65412581168e88a1e60c6459d7f44ae83ad0832e670826c05a4e2476b57af7528484604051610f90929190612622565b60405180910390a2603c8303610ff457837f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd2610fcb84611cbf565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390a25b60008481526001602090815260408083208684528252909120835161101b9285019061233c565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff821633036110cb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c660000000000000000000000000000000000000000000000606482015260840160405180910390fd5b336000818152600b6020908152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b6000838152600560209081526040808320600483528184205484528252808320858452825280832061ffff851684529091529020805460609190610d2590612b12565b60608167ffffffffffffffff8111156111c0576111c06126e6565b6040519080825280602002602001820160405280156111f357816020015b60608152602001906001900390816111de5790505b50905060005b828110156112b9576000803086868581811061121757611217612ae3565b90506020028101906112299190612b65565b604051611237929190612a76565b600060405180830381855af49150503d8060008114611272576040519150601f19603f3d011682016040523d82523d6000602084013e611277565b606091505b50915091508161128657600080fd5b8084848151811061129957611299612ae3565b6020026020010181905250505080806112b190612bca565b9150506111f9565b5092915050565b806112ca8161163f565b6112d357600080fd5b60008281526004602052604081208054916112ed83612bca565b909155505060405182907fb757169b8492ca2f1c6619d9d76ce22803035c3b1d5f6930dffe7b127c1a198390600090a25050565b6000818152600260205260409020805460609190610dc990612b12565b826113488161163f565b61135157600080fd5b6000848152600360205260408120805461136a90612b12565b80601f016020809104026020016040519081016040528092919081815260200182805461139690612b12565b80156113e35780601f106113b8576101008083540402835291602001916113e3565b820191906000526020600020905b8154815290600101906020018083116113c657829003601f168201915b50505060008881526003602052604090209293506114069291508690508561229a565b50847f8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f8582868660405161143b93929190612c02565b60405180910390a25050505050565b816114548161163f565b61145d57600080fd5b61146c83603c61034f85611ce7565b505050565b8261147b8161163f565b61148457600080fd5b60008481526007602090815260408083207fffffffff0000000000000000000000000000000000000000000000000000000087168085529083529281902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8716908117909155905190815286917f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa910160405180910390a350505050565b6000828152600160209081526040808320848452909152902080546060919061156390612b12565b80601f016020809104026020016040519081016040528092919081815260200182805461158f90612b12565b80156115dc5780601f106115b1576101008083540402835291602001916115dc565b820191906000526020600020905b8154815290600101906020018083116115bf57829003601f168201915b5050505050905092915050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f59d1d43c00000000000000000000000000000000000000000000000000000000148061049d575061049d82611d20565b60003373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614806116ba57503373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016145b156116c757506001919050565b6040517f02571be3000000000000000000000000000000000000000000000000000000008152600481018390526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906302571be390602401602060405180830381865afa158015611755573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117799190612c32565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611880576040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015611859573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061187d9190612c32565b90505b73ffffffffffffffffffffffffffffffffffffffff8116331480610ce0575073ffffffffffffffffffffffffffffffffffffffff81166000908152600b6020908152604080832033845290915290205460ff16610ce0565b6119266040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c0810182905261049d81611bd7565b6020810151815160609161049d916119519082611d76565b84519190611dd8565b60a081015160c082015160609161049d91611951908290612a5f565b600081518351148015610ce05750610ce08360008460008751611e4f565b600087815260046020908152604082205488519189019190912090916119bb878787611dd8565b90508315611ac45760008a81526005602090815260408083208684528252808320858452825280832061ffff8c168452909152902080546119fb90612b12565b159050611a4f5760008a815260066020908152604080832086845282528083208584529091528120805461ffff1691611a3383612c4f565b91906101000a81548161ffff021916908361ffff160217905550505b60008a81526005602090815260408083208684528252808320858452825280832061ffff8c1684529091528120611a85916123b0565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051611ab7929190612c8b565b60405180910390a2611bcb565b60008a81526005602090815260408083208684528252808320858452825280832061ffff8c16845290915290208054611afc90612b12565b9050600003611b525760008a815260066020908152604080832086845282528083208584529091528120805461ffff1691611b3683612cb1565b91906101000a81548161ffff021916908361ffff160217905550505b60008a81526005602090815260408083208684528252808320858452825280832061ffff8c16845282529091208251611b8d9284019061233c565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a84604051611bc293929190612cd2565b60405180910390a25b50505050505050505050565b60c08101516020820181905281515111611bee5750565b6000611c0282600001518360200151611d76565b8260200151611c119190612d01565b8251909150611c209082611e72565b61ffff166040830152611c34600282612d01565b8251909150611c439082611e72565b61ffff166060830152611c57600282612d01565b8251909150611c669082611e9a565b63ffffffff166080830152611c7c600482612d01565b8251909150600090611c8e9083611e72565b61ffff169050611c9f600283612d01565b60a084018190529150611cb28183612d01565b60c0909301929092525050565b60008151601414611ccf57600080fd5b50602001516c01000000000000000000000000900490565b6040805160148082528183019092526060916020820181803683375050506c010000000000000000000000009290920260208301525090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167fc869023300000000000000000000000000000000000000000000000000000000148061049d575061049d82611ec4565b6000815b83518110611d8a57611d8a612d19565b6000611d968583611f1a565b60ff169050611da6816001612d01565b611db09083612d01565b915080600003611dc05750611dc6565b50611d7a565b611dd08382612a5f565b949350505050565b8251606090611de78385612d01565b1115611df257600080fd5b60008267ffffffffffffffff811115611e0d57611e0d6126e6565b6040519080825280601f01601f191660200182016040528015611e37576020820181803683370190505b50905060208082019086860101610ab0828287611f3e565b6000611e5c848484611fb2565b611e67878785611fb2565b149695505050505050565b8151600090611e82836002612d01565b1115611e8d57600080fd5b50016002015161ffff1690565b8151600090611eaa836004612d01565b1115611eb557600080fd5b50016004015163ffffffff1690565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f691f343100000000000000000000000000000000000000000000000000000000148061049d575061049d82611fd6565b6000828281518110611f2e57611f2e612ae3565b016020015160f81c905092915050565b60208110611f765781518352611f55602084612d01565b9250611f62602083612d01565b9150611f6f602082612a5f565b9050611f3e565b905182516020929092036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169116179052565b8251600090611fc18385612d01565b1115611fcc57600080fd5b5091016020012090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f124a319c00000000000000000000000000000000000000000000000000000000148061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167fa8fa56820000000000000000000000000000000000000000000000000000000014806120ba57507fffffffff0000000000000000000000000000000000000000000000000000000082167f5c98042b00000000000000000000000000000000000000000000000000000000145b8061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167fbc1c58d100000000000000000000000000000000000000000000000000000000148061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167f3b3b57de0000000000000000000000000000000000000000000000000000000014806121a857507fffffffff0000000000000000000000000000000000000000000000000000000082167ff1cb7e0600000000000000000000000000000000000000000000000000000000145b8061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167f2203ab5600000000000000000000000000000000000000000000000000000000148061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167fac9650d800000000000000000000000000000000000000000000000000000000148061049d57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461049d565b8280546122a690612b12565b90600052602060002090601f0160209004810192826122c8576000855561232c565b82601f106122ff578280017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0082351617855561232c565b8280016001018555821561232c579182015b8281111561232c578235825591602001919060010190612311565b506123389291506123ed565b5090565b82805461234890612b12565b90600052602060002090601f01602090048101928261236a576000855561232c565b82601f1061238357805160ff191683800117855561232c565b8280016001018555821561232c579182015b8281111561232c578251825591602001919060010190612395565b5080546123bc90612b12565b6000825580601f106123cc575050565b601f0160209004906000526020600020908101906123ea91906123ed565b50565b5b8082111561233857600081556001016123ee565b80357fffffffff000000000000000000000000000000000000000000000000000000008116811461243257600080fd5b919050565b60006020828403121561244957600080fd5b610ce082612402565b60008083601f84011261246457600080fd5b50813567ffffffffffffffff81111561247c57600080fd5b602083019150836020828501011115610bcf57600080fd5b6000806000604084860312156124a957600080fd5b83359250602084013567ffffffffffffffff8111156124c757600080fd5b6124d386828701612452565b9497909650939450505050565b6000806000806000606086880312156124f857600080fd5b85359450602086013567ffffffffffffffff8082111561251757600080fd5b61252389838a01612452565b9096509450604088013591508082111561253c57600080fd5b5061254988828901612452565b969995985093965092949392505050565b6000806040838503121561256d57600080fd5b8235915061257d60208401612402565b90509250929050565b6000806040838503121561259957600080fd5b50508035926020909101359150565b60005b838110156125c35781810151838201526020016125ab565b838111156125d2576000848401525b50505050565b600081518084526125f08160208601602086016125a8565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b828152604060208201526000611dd060408301846125d8565b60008060006060848603121561265057600080fd5b505081359360208301359350604090920135919050565b60006020828403121561267957600080fd5b5035919050565b602081526000610ce060208301846125d8565b600080600080606085870312156126a957600080fd5b8435935060208501359250604085013567ffffffffffffffff8111156126ce57600080fd5b6126da87828801612452565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060006060848603121561272a57600080fd5b8335925060208401359150604084013567ffffffffffffffff8082111561275057600080fd5b818601915086601f83011261276457600080fd5b813581811115612776576127766126e6565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156127bc576127bc6126e6565b816040528281528960208487010111156127d557600080fd5b8260208601602083013760006020848301015280955050505050509250925092565b73ffffffffffffffffffffffffffffffffffffffff811681146123ea57600080fd5b6000806040838503121561282c57600080fd5b8235612837816127f7565b91506020830135801515811461284c57600080fd5b809150509250929050565b60008060006060848603121561286c57600080fd5b8335925060208401359150604084013561ffff8116811461288c57600080fd5b809150509250925092565b600080602083850312156128aa57600080fd5b823567ffffffffffffffff808211156128c257600080fd5b818501915085601f8301126128d657600080fd5b8135818111156128e557600080fd5b8660208260051b85010111156128fa57600080fd5b60209290920196919550909350505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561297f577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088860301845261296d8583516125d8565b94509285019290850190600101612933565b5092979650505050505050565b6000806040838503121561299f57600080fd5b82359150602083013561284c816127f7565b6000806000606084860312156129c657600080fd5b833592506129d660208501612402565b9150604084013561288c816127f7565b600080604083850312156129f957600080fd5b8235612a04816127f7565b9150602083013561284c816127f7565b60008251612a268184602087016125a8565b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082821015612a7157612a71612a30565b500390565b8183823760009101908152919050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b602081526000611dd0602083018486612a86565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600181811c90821680612b2657607f821691505b602082108103612b5f577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112612b9a57600080fd5b83018035915067ffffffffffffffff821115612bb557600080fd5b602001915036819003821315610bcf57600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612bfb57612bfb612a30565b5060010190565b604081526000612c1560408301866125d8565b8281036020840152612c28818587612a86565b9695505050505050565b600060208284031215612c4457600080fd5b8151610ce0816127f7565b600061ffff821680612c6357612c63612a30565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0192915050565b604081526000612c9e60408301856125d8565b905061ffff831660208301529392505050565b600061ffff808316818103612cc857612cc8612a30565b6001019392505050565b606081526000612ce560608301866125d8565b61ffff851660208401528281036040840152612c2881856125d8565b60008219821115612d1457612d14612a30565b500190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fdfea264697066735822122017b3e680dc23d712e3971f2217d550695e594a6f174f0ed1adabba4ba578aac564736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101ae5760003560e01c806377372213116100ee578063bc1c58d111610097578063d5fa2b0011610071578063d5fa2b0014610410578063e59d895d14610423578063e985e9c514610436578063f1cb7e061461047f57600080fd5b8063bc1c58d1146103ad578063c8690233146103c0578063ce3decdc146103fd57600080fd5b8063a8fa5682116100c8578063a8fa568214610367578063ac9650d81461037a578063ad5780af1461039a57600080fd5b8063773722131461032e5780638b95dd7114610341578063a22cb4651461035457600080fd5b8063304e6ade1161015b57806359d1d43c1161013557806359d1d43c146102d55780635c98042b146102f5578063623195b014610308578063691f34311461031b57600080fd5b8063304e6ade1461026f5780633b3b57de146102825780634cbf6ba41461029557600080fd5b8063124a319c1161018c578063124a319c146102035780632203ab561461023b57806329cd62ea1461025c57600080fd5b806301ffc9a7146101b35780630af179d7146101db57806310f13a8c146101f0575b600080fd5b6101c66101c1366004612437565b610492565b60405190151581526020015b60405180910390f35b6101ee6101e9366004612494565b6104a3565b005b6101ee6101fe3660046124e0565b610691565b61021661021136600461255a565b61073e565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101d2565b61024e610249366004612586565b610abb565b6040516101d2929190612622565b6101ee61026a36600461263b565b610bd6565b6101ee61027d366004612494565b610c56565b610216610290366004612667565b610cb5565b6101c66102a3366004612586565b600091825260066020908152604080842060048352818520548552825280842092845291905290205461ffff16151590565b6102e86102e3366004612494565b610ce7565b6040516101d29190612680565b6102e8610303366004612667565b610dac565b6101ee610316366004612693565b610e4e565b6102e8610329366004612667565b610ecf565b6101ee61033c366004612494565b610eec565b6101ee61034f366004612715565b610f4b565b6101ee610362366004612819565b611022565b6102e8610375366004612857565b611162565b61038d610388366004612897565b6111a5565b6040516101d2919061290c565b6101ee6103a8366004612667565b6112c0565b6102e86103bb366004612667565b611321565b6103e86103ce366004612667565b600090815260096020526040902080546001909101549091565b604080519283526020830191909152016101d2565b6101ee61040b366004612494565b61133e565b6101ee61041e36600461298c565b61144a565b6101ee6104313660046129b1565b611471565b6101c66104443660046129e6565b73ffffffffffffffffffffffffffffffffffffffff9182166000908152600b6020908152604080832093909416825291909152205460ff1690565b6102e861048d366004612586565b61153b565b600061049d826115e9565b92915050565b826104ad8161163f565b6104b657600080fd5b60008060608060008061050360008a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506118d89050565b90505b8051516020820151101561062c578561ffff1660000361056b578060400151955061053081611939565b9350836040516020016105439190612a14565b6040516020818303038152906040528051906020012091506105648161195a565b925061061e565b600061057682611939565b9050816040015161ffff168761ffff1614158061059a57506105988582611976565b155b1561061c576105f58b86898d8d8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505060208801518c91506105ed908290612a5f565b8a5115611994565b8160400151965081602001519550809450848051906020012092506106198261195a565b93505b505b61062781611bd7565b610506565b50825115610686576106868984878b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508b925061067e91508290508e612a5f565b885115611994565b505050505050505050565b8461069b8161163f565b6106a457600080fd5b8282600a600089815260200190815260200160002087876040516106c9929190612a76565b9081526040519081900360200190206106e392909161229a565b5084846040516106f4929190612a76565b6040518091039020867fd8c9334b1a9c2f9da342a0a2b32629c1a229b6445dad78947f674b44444a7550878760405161072e929190612acf565b60405180910390a3505050505050565b60008281526007602090815260408083207fffffffff000000000000000000000000000000000000000000000000000000008516845290915281205473ffffffffffffffffffffffffffffffffffffffff16801561079d57905061049d565b60006107a885610cb5565b905073ffffffffffffffffffffffffffffffffffffffff81166107d05760009250505061049d565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000006024820152600090819073ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a7000000000000000000000000000000000000000000000000000000001790525161089a9190612a14565b600060405180830381855afa9150503d80600081146108d5576040519150601f19603f3d011682016040523d82523d6000602084013e6108da565b606091505b50915091508115806108ed575060208151105b8061092f575080601f8151811061090657610906612ae3565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b1561094157600094505050505061049d565b6040517fffffffff000000000000000000000000000000000000000000000000000000008716602482015273ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a70000000000000000000000000000000000000000000000000000000017905251610a089190612a14565b600060405180830381855afa9150503d8060008114610a43576040519150601f19603f3d011682016040523d82523d6000602084013e610a48565b606091505b509092509050811580610a5c575060208151105b80610a9e575080601f81518110610a7557610a75612ae3565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b15610ab057600094505050505061049d565b509095945050505050565b600082815260208190526040812060609060015b848111610bb65780851615801590610aff575060008181526020839052604081208054610afb90612b12565b9050115b15610bae5780826000838152602001908152602001600020808054610b2390612b12565b80601f0160208091040260200160405190810160405280929190818152602001828054610b4f90612b12565b8015610b9c5780601f10610b7157610100808354040283529160200191610b9c565b820191906000526020600020905b815481529060010190602001808311610b7f57829003601f168201915b50505050509050935093505050610bcf565b60011b610acf565b5060006040518060200160405280600081525092509250505b9250929050565b82610be08161163f565b610be957600080fd5b60408051808201825284815260208082018581526000888152600983528490209251835551600190920191909155815185815290810184905285917f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e4691015b60405180910390a250505050565b82610c608161163f565b610c6957600080fd5b6000848152600260205260409020610c8290848461229a565b50837fe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d75788484604051610c48929190612acf565b600080610cc383603c61153b565b90508051600003610cd75750600092915050565b610ce081611cbf565b9392505050565b6060600a60008581526020019081526020016000208383604051610d0c929190612a76565b90815260200160405180910390208054610d2590612b12565b80601f0160208091040260200160405190810160405280929190818152602001828054610d5190612b12565b8015610d9e5780601f10610d7357610100808354040283529160200191610d9e565b820191906000526020600020905b815481529060010190602001808311610d8157829003601f168201915b505050505090509392505050565b6000818152600360205260409020805460609190610dc990612b12565b80601f0160208091040260200160405190810160405280929190818152602001828054610df590612b12565b8015610e425780601f10610e1757610100808354040283529160200191610e42565b820191906000526020600020905b815481529060010190602001808311610e2557829003601f168201915b50505050509050919050565b83610e588161163f565b610e6157600080fd5b83610e6d600182612a5f565b1615610e7857600080fd5b6000858152602081815260408083208784529091529020610e9a90848461229a565b50604051849086907faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe390600090a35050505050565b6000818152600860205260409020805460609190610dc990612b12565b82610ef68161163f565b610eff57600080fd5b6000848152600860205260409020610f1890848461229a565b50837fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f78484604051610c48929190612acf565b82610f558161163f565b610f5e57600080fd5b837f65412581168e88a1e60c6459d7f44ae83ad0832e670826c05a4e2476b57af7528484604051610f90929190612622565b60405180910390a2603c8303610ff457837f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd2610fcb84611cbf565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390a25b60008481526001602090815260408083208684528252909120835161101b9285019061233c565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff821633036110cb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c660000000000000000000000000000000000000000000000606482015260840160405180910390fd5b336000818152600b6020908152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b6000838152600560209081526040808320600483528184205484528252808320858452825280832061ffff851684529091529020805460609190610d2590612b12565b60608167ffffffffffffffff8111156111c0576111c06126e6565b6040519080825280602002602001820160405280156111f357816020015b60608152602001906001900390816111de5790505b50905060005b828110156112b9576000803086868581811061121757611217612ae3565b90506020028101906112299190612b65565b604051611237929190612a76565b600060405180830381855af49150503d8060008114611272576040519150601f19603f3d011682016040523d82523d6000602084013e611277565b606091505b50915091508161128657600080fd5b8084848151811061129957611299612ae3565b6020026020010181905250505080806112b190612bca565b9150506111f9565b5092915050565b806112ca8161163f565b6112d357600080fd5b60008281526004602052604081208054916112ed83612bca565b909155505060405182907fb757169b8492ca2f1c6619d9d76ce22803035c3b1d5f6930dffe7b127c1a198390600090a25050565b6000818152600260205260409020805460609190610dc990612b12565b826113488161163f565b61135157600080fd5b6000848152600360205260408120805461136a90612b12565b80601f016020809104026020016040519081016040528092919081815260200182805461139690612b12565b80156113e35780601f106113b8576101008083540402835291602001916113e3565b820191906000526020600020905b8154815290600101906020018083116113c657829003601f168201915b50505060008881526003602052604090209293506114069291508690508561229a565b50847f8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f8582868660405161143b93929190612c02565b60405180910390a25050505050565b816114548161163f565b61145d57600080fd5b61146c83603c61034f85611ce7565b505050565b8261147b8161163f565b61148457600080fd5b60008481526007602090815260408083207fffffffff0000000000000000000000000000000000000000000000000000000087168085529083529281902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8716908117909155905190815286917f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa910160405180910390a350505050565b6000828152600160209081526040808320848452909152902080546060919061156390612b12565b80601f016020809104026020016040519081016040528092919081815260200182805461158f90612b12565b80156115dc5780601f106115b1576101008083540402835291602001916115dc565b820191906000526020600020905b8154815290600101906020018083116115bf57829003601f168201915b5050505050905092915050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f59d1d43c00000000000000000000000000000000000000000000000000000000148061049d575061049d82611d20565b60003373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614806116ba57503373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016145b156116c757506001919050565b6040517f02571be3000000000000000000000000000000000000000000000000000000008152600481018390526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906302571be390602401602060405180830381865afa158015611755573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117799190612c32565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611880576040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015611859573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061187d9190612c32565b90505b73ffffffffffffffffffffffffffffffffffffffff8116331480610ce0575073ffffffffffffffffffffffffffffffffffffffff81166000908152600b6020908152604080832033845290915290205460ff16610ce0565b6119266040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c0810182905261049d81611bd7565b6020810151815160609161049d916119519082611d76565b84519190611dd8565b60a081015160c082015160609161049d91611951908290612a5f565b600081518351148015610ce05750610ce08360008460008751611e4f565b600087815260046020908152604082205488519189019190912090916119bb878787611dd8565b90508315611ac45760008a81526005602090815260408083208684528252808320858452825280832061ffff8c168452909152902080546119fb90612b12565b159050611a4f5760008a815260066020908152604080832086845282528083208584529091528120805461ffff1691611a3383612c4f565b91906101000a81548161ffff021916908361ffff160217905550505b60008a81526005602090815260408083208684528252808320858452825280832061ffff8c1684529091528120611a85916123b0565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051611ab7929190612c8b565b60405180910390a2611bcb565b60008a81526005602090815260408083208684528252808320858452825280832061ffff8c16845290915290208054611afc90612b12565b9050600003611b525760008a815260066020908152604080832086845282528083208584529091528120805461ffff1691611b3683612cb1565b91906101000a81548161ffff021916908361ffff160217905550505b60008a81526005602090815260408083208684528252808320858452825280832061ffff8c16845282529091208251611b8d9284019061233c565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a84604051611bc293929190612cd2565b60405180910390a25b50505050505050505050565b60c08101516020820181905281515111611bee5750565b6000611c0282600001518360200151611d76565b8260200151611c119190612d01565b8251909150611c209082611e72565b61ffff166040830152611c34600282612d01565b8251909150611c439082611e72565b61ffff166060830152611c57600282612d01565b8251909150611c669082611e9a565b63ffffffff166080830152611c7c600482612d01565b8251909150600090611c8e9083611e72565b61ffff169050611c9f600283612d01565b60a084018190529150611cb28183612d01565b60c0909301929092525050565b60008151601414611ccf57600080fd5b50602001516c01000000000000000000000000900490565b6040805160148082528183019092526060916020820181803683375050506c010000000000000000000000009290920260208301525090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167fc869023300000000000000000000000000000000000000000000000000000000148061049d575061049d82611ec4565b6000815b83518110611d8a57611d8a612d19565b6000611d968583611f1a565b60ff169050611da6816001612d01565b611db09083612d01565b915080600003611dc05750611dc6565b50611d7a565b611dd08382612a5f565b949350505050565b8251606090611de78385612d01565b1115611df257600080fd5b60008267ffffffffffffffff811115611e0d57611e0d6126e6565b6040519080825280601f01601f191660200182016040528015611e37576020820181803683370190505b50905060208082019086860101610ab0828287611f3e565b6000611e5c848484611fb2565b611e67878785611fb2565b149695505050505050565b8151600090611e82836002612d01565b1115611e8d57600080fd5b50016002015161ffff1690565b8151600090611eaa836004612d01565b1115611eb557600080fd5b50016004015163ffffffff1690565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f691f343100000000000000000000000000000000000000000000000000000000148061049d575061049d82611fd6565b6000828281518110611f2e57611f2e612ae3565b016020015160f81c905092915050565b60208110611f765781518352611f55602084612d01565b9250611f62602083612d01565b9150611f6f602082612a5f565b9050611f3e565b905182516020929092036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169116179052565b8251600090611fc18385612d01565b1115611fcc57600080fd5b5091016020012090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f124a319c00000000000000000000000000000000000000000000000000000000148061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167fa8fa56820000000000000000000000000000000000000000000000000000000014806120ba57507fffffffff0000000000000000000000000000000000000000000000000000000082167f5c98042b00000000000000000000000000000000000000000000000000000000145b8061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167fbc1c58d100000000000000000000000000000000000000000000000000000000148061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167f3b3b57de0000000000000000000000000000000000000000000000000000000014806121a857507fffffffff0000000000000000000000000000000000000000000000000000000082167ff1cb7e0600000000000000000000000000000000000000000000000000000000145b8061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167f2203ab5600000000000000000000000000000000000000000000000000000000148061049d575061049d8260007fffffffff0000000000000000000000000000000000000000000000000000000082167fac9650d800000000000000000000000000000000000000000000000000000000148061049d57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461049d565b8280546122a690612b12565b90600052602060002090601f0160209004810192826122c8576000855561232c565b82601f106122ff578280017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0082351617855561232c565b8280016001018555821561232c579182015b8281111561232c578235825591602001919060010190612311565b506123389291506123ed565b5090565b82805461234890612b12565b90600052602060002090601f01602090048101928261236a576000855561232c565b82601f1061238357805160ff191683800117855561232c565b8280016001018555821561232c579182015b8281111561232c578251825591602001919060010190612395565b5080546123bc90612b12565b6000825580601f106123cc575050565b601f0160209004906000526020600020908101906123ea91906123ed565b50565b5b8082111561233857600081556001016123ee565b80357fffffffff000000000000000000000000000000000000000000000000000000008116811461243257600080fd5b919050565b60006020828403121561244957600080fd5b610ce082612402565b60008083601f84011261246457600080fd5b50813567ffffffffffffffff81111561247c57600080fd5b602083019150836020828501011115610bcf57600080fd5b6000806000604084860312156124a957600080fd5b83359250602084013567ffffffffffffffff8111156124c757600080fd5b6124d386828701612452565b9497909650939450505050565b6000806000806000606086880312156124f857600080fd5b85359450602086013567ffffffffffffffff8082111561251757600080fd5b61252389838a01612452565b9096509450604088013591508082111561253c57600080fd5b5061254988828901612452565b969995985093965092949392505050565b6000806040838503121561256d57600080fd5b8235915061257d60208401612402565b90509250929050565b6000806040838503121561259957600080fd5b50508035926020909101359150565b60005b838110156125c35781810151838201526020016125ab565b838111156125d2576000848401525b50505050565b600081518084526125f08160208601602086016125a8565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b828152604060208201526000611dd060408301846125d8565b60008060006060848603121561265057600080fd5b505081359360208301359350604090920135919050565b60006020828403121561267957600080fd5b5035919050565b602081526000610ce060208301846125d8565b600080600080606085870312156126a957600080fd5b8435935060208501359250604085013567ffffffffffffffff8111156126ce57600080fd5b6126da87828801612452565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060006060848603121561272a57600080fd5b8335925060208401359150604084013567ffffffffffffffff8082111561275057600080fd5b818601915086601f83011261276457600080fd5b813581811115612776576127766126e6565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156127bc576127bc6126e6565b816040528281528960208487010111156127d557600080fd5b8260208601602083013760006020848301015280955050505050509250925092565b73ffffffffffffffffffffffffffffffffffffffff811681146123ea57600080fd5b6000806040838503121561282c57600080fd5b8235612837816127f7565b91506020830135801515811461284c57600080fd5b809150509250929050565b60008060006060848603121561286c57600080fd5b8335925060208401359150604084013561ffff8116811461288c57600080fd5b809150509250925092565b600080602083850312156128aa57600080fd5b823567ffffffffffffffff808211156128c257600080fd5b818501915085601f8301126128d657600080fd5b8135818111156128e557600080fd5b8660208260051b85010111156128fa57600080fd5b60209290920196919550909350505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561297f577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088860301845261296d8583516125d8565b94509285019290850190600101612933565b5092979650505050505050565b6000806040838503121561299f57600080fd5b82359150602083013561284c816127f7565b6000806000606084860312156129c657600080fd5b833592506129d660208501612402565b9150604084013561288c816127f7565b600080604083850312156129f957600080fd5b8235612a04816127f7565b9150602083013561284c816127f7565b60008251612a268184602087016125a8565b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082821015612a7157612a71612a30565b500390565b8183823760009101908152919050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b602081526000611dd0602083018486612a86565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600181811c90821680612b2657607f821691505b602082108103612b5f577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112612b9a57600080fd5b83018035915067ffffffffffffffff821115612bb557600080fd5b602001915036819003821315610bcf57600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612bfb57612bfb612a30565b5060010190565b604081526000612c1560408301866125d8565b8281036020840152612c28818587612a86565b9695505050505050565b600060208284031215612c4457600080fd5b8151610ce0816127f7565b600061ffff821680612c6357612c63612a30565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0192915050565b604081526000612c9e60408301856125d8565b905061ffff831660208301529392505050565b600061ffff808316818103612cc857612cc8612a30565b6001019392505050565b606081526000612ce560608301866125d8565b61ffff851660208401528281036040840152612c2881856125d8565b60008219821115612d1457612d14612a30565b500190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fdfea264697066735822122017b3e680dc23d712e3971f2217d550695e594a6f174f0ed1adabba4ba578aac564736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "ABI(bytes32,uint256)": {
        "params": {
          "contentTypes": "A bitwise OR of the ABI formats accepted by the caller.",
          "node": "The ENS node to query"
        },
        "returns": {
          "_0": "contentType The content type of the return value",
          "_1": "data The ABI data"
        }
      },
      "addr(bytes32)": {
        "params": {
          "node": "The ENS node to query."
        },
        "returns": {
          "_0": "The associated address."
        }
      },
      "clearDNSZone(bytes32)": {
        "params": {
          "node": "the namehash of the node for which to clear the zone"
        }
      },
      "contenthash(bytes32)": {
        "params": {
          "node": "The ENS node to query."
        },
        "returns": {
          "_0": "The associated contenthash."
        }
      },
      "dnsRecord(bytes32,bytes32,uint16)": {
        "params": {
          "name": "the keccak-256 hash of the fully-qualified name for which to fetch the record",
          "node": "the namehash of the node for which to fetch the record",
          "resource": "the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types"
        },
        "returns": {
          "_0": "the DNS record in wire format if present, otherwise empty"
        }
      },
      "hasDNSRecords(bytes32,bytes32)": {
        "params": {
          "name": "the namehash of the node for which to check the records",
          "node": "the namehash of the node for which to check the records"
        }
      },
      "interfaceImplementer(bytes32,bytes4)": {
        "params": {
          "interfaceID": "The EIP 165 interface ID to check for.",
          "node": "The ENS node to query."
        },
        "returns": {
          "_0": "The address that implements this interface, or 0 if the interface is unsupported."
        }
      },
      "isApprovedForAll(address,address)": {
        "details": "See {IERC1155-isApprovedForAll}."
      },
      "name(bytes32)": {
        "params": {
          "node": "The ENS node to query."
        },
        "returns": {
          "_0": "The associated name."
        }
      },
      "pubkey(bytes32)": {
        "params": {
          "node": "The ENS node to query"
        },
        "returns": {
          "x": "The X coordinate of the curve point for the public key.",
          "y": "The Y coordinate of the curve point for the public key."
        }
      },
      "setABI(bytes32,uint256,bytes)": {
        "params": {
          "contentType": "The content type of the ABI",
          "data": "The ABI data.",
          "node": "The node to update."
        }
      },
      "setAddr(bytes32,address)": {
        "params": {
          "a": "The address to set.",
          "node": "The node to update."
        }
      },
      "setApprovalForAll(address,bool)": {
        "details": "See {IERC1155-setApprovalForAll}."
      },
      "setContenthash(bytes32,bytes)": {
        "params": {
          "hash": "The contenthash to set",
          "node": "The node to update."
        }
      },
      "setDNSRecords(bytes32,bytes)": {
        "params": {
          "data": "the DNS wire format records to set",
          "node": "the namehash of the node for which to set the records"
        }
      },
      "setInterface(bytes32,bytes4,address)": {
        "params": {
          "implementer": "The address of a contract that implements this interface for this node.",
          "interfaceID": "The EIP 165 interface ID.",
          "node": "The node to update."
        }
      },
      "setName(bytes32,string)": {
        "params": {
          "node": "The node to update."
        }
      },
      "setPubkey(bytes32,bytes32,bytes32)": {
        "params": {
          "node": "The ENS node to query",
          "x": "the X coordinate of the curve point for the public key.",
          "y": "the Y coordinate of the curve point for the public key."
        }
      },
      "setText(bytes32,string,string)": {
        "params": {
          "key": "The key to set.",
          "node": "The node to update.",
          "value": "The text data value to set."
        }
      },
      "setZonehash(bytes32,bytes)": {
        "params": {
          "hash": "The zonehash to set",
          "node": "The node to update."
        }
      },
      "text(bytes32,string)": {
        "params": {
          "key": "The text data key to query.",
          "node": "The ENS node to query."
        },
        "returns": {
          "_0": "The associated text data."
        }
      },
      "zonehash(bytes32)": {
        "params": {
          "node": "The ENS node to query."
        },
        "returns": {
          "_0": "The associated contenthash."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "ABI(bytes32,uint256)": {
        "notice": "Returns the ABI associated with an ENS node. Defined in EIP205."
      },
      "addr(bytes32)": {
        "notice": "Returns the address associated with an ENS node."
      },
      "clearDNSZone(bytes32)": {
        "notice": "Clear all information for a DNS zone."
      },
      "contenthash(bytes32)": {
        "notice": "Returns the contenthash associated with an ENS node."
      },
      "dnsRecord(bytes32,bytes32,uint16)": {
        "notice": "Obtain a DNS record."
      },
      "hasDNSRecords(bytes32,bytes32)": {
        "notice": "Check if a given node has records."
      },
      "interfaceImplementer(bytes32,bytes4)": {
        "notice": "Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP165 and returns `true` for the specified interfaceID, its address will be returned."
      },
      "name(bytes32)": {
        "notice": "Returns the name associated with an ENS node, for reverse records. Defined in EIP181."
      },
      "pubkey(bytes32)": {
        "notice": "Returns the SECP256k1 public key associated with an ENS node. Defined in EIP 619."
      },
      "setABI(bytes32,uint256,bytes)": {
        "notice": "Sets the ABI associated with an ENS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string."
      },
      "setAddr(bytes32,address)": {
        "notice": "Sets the address associated with an ENS node. May only be called by the owner of that node in the ENS registry."
      },
      "setContenthash(bytes32,bytes)": {
        "notice": "Sets the contenthash associated with an ENS node. May only be called by the owner of that node in the ENS registry."
      },
      "setDNSRecords(bytes32,bytes)": {
        "notice": "Set one or more DNS records.  Records are supplied in wire-format. Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:     a.example.com IN A 1.2.3.4     a.example.com IN A 5.6.7.8     www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:     a.example.com IN A 1.2.3.4     www.example.com IN CNAME a.example.com.     a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first."
      },
      "setInterface(bytes32,bytes4,address)": {
        "notice": "Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support."
      },
      "setName(bytes32,string)": {
        "notice": "Sets the name associated with an ENS node, for reverse records. May only be called by the owner of that node in the ENS registry."
      },
      "setPubkey(bytes32,bytes32,bytes32)": {
        "notice": "Sets the SECP256k1 public key associated with an ENS node."
      },
      "setText(bytes32,string,string)": {
        "notice": "Sets the text data associated with an ENS node and key. May only be called by the owner of that node in the ENS registry."
      },
      "setZonehash(bytes32,bytes)": {
        "notice": "setZonehash sets the hash for the zone. May only be called by the owner of that node in the ENS registry."
      },
      "text(bytes32,string)": {
        "notice": "Returns the text data associated with an ENS node and key."
      },
      "zonehash(bytes32)": {
        "notice": "zonehash obtains the hash for the zone."
      }
    },
    "notice": "A simple resolver anyone can use; only allows the owner of a node to set its address.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 14396,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "abis",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage))"
      },
      {
        "astId": 14540,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_addresses",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage))"
      },
      {
        "astId": 14721,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "hashes",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_bytes_storage)"
      },
      {
        "astId": 14801,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "zonehashes",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_bytes32,t_bytes_storage)"
      },
      {
        "astId": 14805,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "versions",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 14815,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "records",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_bytes32,t_mapping(t_uint256,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))))"
      },
      {
        "astId": 14823,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "nameEntriesCount",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_bytes32,t_mapping(t_uint256,t_mapping(t_bytes32,t_uint16)))"
      },
      {
        "astId": 15504,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "interfaces",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_bytes32,t_mapping(t_bytes4,t_address))"
      },
      {
        "astId": 15686,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "names",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_bytes32,t_string_storage)"
      },
      {
        "astId": 15763,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "pubkeys",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_bytes32,t_struct(PublicKey)15758_storage)"
      },
      {
        "astId": 15850,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "texts",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage))"
      },
      {
        "astId": 14031,
        "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_operatorApprovals",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_bytes32,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_bytes32,t_mapping(t_bytes4,t_address))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(bytes4 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes4,t_address)"
      },
      "t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(string => string))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_string_memory_ptr,t_string_storage)"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint16 => bytes))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint16,t_bytes_storage)"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint256 => bytes))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bytes_storage)"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint256,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint256 => mapping(bytes32 => mapping(uint16 => bytes))))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage)))"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint256,t_mapping(t_bytes32,t_uint16)))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint256 => mapping(bytes32 => uint16)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_mapping(t_bytes32,t_uint16))"
      },
      "t_mapping(t_bytes32,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_bytes32,t_struct(PublicKey)15758_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct PubkeyResolver.PublicKey)",
        "numberOfBytes": "32",
        "value": "t_struct(PublicKey)15758_storage"
      },
      "t_mapping(t_bytes32,t_uint16)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint16)",
        "numberOfBytes": "32",
        "value": "t_uint16"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes4,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_string_memory_ptr,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_uint16,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_uint16",
        "label": "mapping(uint16 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_uint256,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage)))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(bytes32 => mapping(uint16 => bytes)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))"
      },
      "t_mapping(t_uint256,t_mapping(t_bytes32,t_uint16))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(bytes32 => uint16))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint16)"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(PublicKey)15758_storage": {
        "encoding": "inplace",
        "label": "struct PubkeyResolver.PublicKey",
        "members": [
          {
            "astId": 15755,
            "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
            "label": "x",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 15757,
            "contract": "contracts/resolvers/PublicResolver.sol:PublicResolver",
            "label": "y",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}